## 4. Array and Loop

***

 

**Array**

여러 개의 변수를 한 번에 선언해 다룰 수 있는 자료형을 **배열**이라고 한다 

배열 내부에 있는 값을 **요소**라고 한다

배열의 여러 속성과 메소드들을 통해 요소들을 효율적으로 다룰 수 있다

 .

**파괴적 처리**는 메모리를 절약 할 수 있지만 원본이 사라지기 때문에 위험할 수 있다 

**비파괴적 처리**는 메모리를 차지하지만 원본이 유지된다

메모리가 여유로운 현대의 프로그래밍 언어와 라이브러리는 자료 보호를 위해 대부분 비파괴적 처리를 한다

  .

**Loop** 

while문과 for문은 서로 대체해서 사용할 수 있다

상호 대체 가능하지만, 

횟수를 기준으로 반복할 때에는 for문

조건에 큰 비중을 두고 반복할 때는 whlie문이 효율적이다

상황에 따라 적합한 문법을 골라 사욯하면 된다

 .

자바스크립트에서 무한 반복을 사용하면 페이지 전체가 먹통이 되는 경우가 생긴다

break구문 등을 이용해 반드시 무한 반복을 벗어나도록 하고 사용에 유의하자

 .

break키워드나 continue키워드는 반복문의 조건식을 적절하게 만들면 필요없다

 .

조건문이나 반복문을 쓸 때 일단 자기가 쓰고 있는 코드가 맞다고 생각하며 쓰면 잘 써진다 -홍-

처음쓰는 코드가 더워러 지는 것에 크게 신경쓰지 말기 일단 조건에 맞춰 실행만 되면 ok

***



## 5. Function

***

 장점 : 

1. 반복 작업을 피할 수 있다
2. 모듈화로 인한 가독성 증가
3. 기능별 유지보수 가능

.

**익명 함수(anonymous funciton)** 는 함수를 출력했을 때 별다른 이름이 붙어있지 않다

이하 후술 하겠지만, 자바스크립트에 있어서 독보적이고 독창적인 시스탬이고 한다.

실제로 선례로서 다른 언어에도 도입되고 있다고 한다

.

**선언적 함수**는 함수를 출력했을 때 이름이 있다. 실질적으로 더 보편적이고 많이 쓰기는 하는 것 같다

.

자바스크립트의 함수는 **나머지 매개변수**라는 시스탬을 통해

매개변수를 동적으로 받을 수 있는 **가변 매개변수 함수**를 만들 수 있다

function f(...items)

위와 같이 ...을 입력하면 몇개가 오든 배열로 받는다

.

나머지 매개변수의 상호보완으로 **전개 연산자**가 있다

함수를 호출 할때, 함수가 가변 매개변수 함수라면

전재 연산자를 통해 배열로도 함수를 간단히 호출 할 수 있다

f(...array)

가변 매개변수 함수에 전개 연산자 없이 배열을 넣으면 배열 객체 자체가 들어간다

.

매개변수에 default 값을 할당 할 수 있다

왼쪽부터 할당하면 의미가 없으므로 오른쪽부터 할당

.

함수도 하나의 자료형이므로 매개변수로 전달 할 수 있다

이때 매개변수로 전달하는 함수를 **콜백함수**라고 한다

.

단순한 형태의 콜백 함수를 쉽게 입력하고자 **화살표 함수**를 쓴다

array.forEach( (value) => { } )

array.forEach( (value) => 리턴값 )

.

어떤 매소드가 리턴하는 값을 기반으로 해서 

함수를 줄줄이 사용하는 것을 메소드 체이닝이라고 한다

.

특정 시간마다 또는 특정 시간 이후에 콜백 함수를 호출하는 함수들을 타이머 함수라고 한다

.

다른 스크립트와의 충돌을 막기위한 섀도잉과정(블록이 다른 경우 내부 변수가 외부 변수를 가림)으로

즉시 호출하는 패턴을 많이 쓴다

(function () { })()

.

**'use strict'**라는 문자열로 엄격모드를 실행 할 수 있다

이런저런 충돌을 막아준다고 하는데 잘은 모르겠다

즉시 호출 함수와 함께 일반적으로 사용하는게 좋다고 한다

(function () { 

​	'use strict'

​	...

})()

.

**익명 함수**는 순차적인 코드 실행에서 코드가 해당 줄을 읽을 때 생성되고

**선언적 함수**는 순차적인 코드 실행이 일어나기 전에 생성 된다 (말 그대로 선언적)

이러한 다른 프로토콜을 가진 두 함수를 잘못 혼용할 시, 불완전한 코드 진행이 일어날 수 있슴

선언적 함수는 씌여진 코드 순서와는 다르게 먼저 생성되고,

익명 함수는 진행 순서대로 덮어 씌우기 때문에 꼬일 수 있다

그래서 대부분 통상적인 진행을 따르는 익명 함수를 let키워드로 감싼 식별자에 할당해서

함수들 간의 충돌을 막고 익명 함수만 쓰는 방법을 선호한다고 함

.

쉽게 장단점을 따지자면 선언적 함수는 익명 함수에 비해 함수의 실행흐름을 예측하기 힘들고

익명 함수를 let으로 감싸므로써 충돌을 막을 수 있슴

***



## 5. Object

***

객체는 추상적인 개념이다

객체는 **실제로 존재하는 사물**을 <u>의미</u>하고

**이름과 값**으로 구성된 **속성**으로 <u>이야기</u> 할 수 있는 자바스크립트의 기본 데이터 타입이다

--일단 이렇게 이해함

.

일단 객체는 기본적으로 여러 자료를 다룰 때 사용한다

그리고 객체 중에서도 배열이 그 기본 원리를 잘 따르고 있으며 쉽게 비유 될 수 있다

배열은 요소에 접근 할 때 인덱스를 이용하지만,

객체는 키를 통해 값을 설정한다

const object = {

​	name = '정구연',

​	old = 23

}

.

요소에 접근하는 방법은 .(온점)과 [ ]가 있는 데, 

객체의 키가 문자열로 되어있다면 무조건 [ ]를 사용해야 된다

object["with dsfa"]

.

배열 내부 값이 요소라면

객체 내부의 값은 **속성**이라고 한다

그리고 속성 중 함수 자료형인 속성은 **메소드**라고 부른다

.

동적으로 속성을 추가 할 땐 직접 접근해서 추가하면 된다 (( student.이름 = '정구연'

동적으로 속성을 제거 할 땐 **delete키워드**를 사용한다 (( delete student.이름

.

메소드 내에서 자기 자신이 가진 속성을 출력하고 싶을 때는 **this키워드**를 사용한다

메소드를 선언 할 때는 익명 함수와 **메소드 간단 선언 구문**을 상용한다

익명 함수)) eat : function (food) { }

메소드 간단 선언 구문)) eat (food) { }

 후자가 훨씬 간단하다

반면에 화살표 함수는 지양하는 것이 좋다

잘은 모르겠는데 this포인터를 쓸때 다른 걸 나타낸다고 한다
